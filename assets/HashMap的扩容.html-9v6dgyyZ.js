import{_ as a,o as s,c as e,a as p}from"./app-oJgUVX7T.js";const l="/assets/image-20230916101657726-C45_ArLQ.png",t={},n=p(`<h1 id="hashmap的扩容" tabindex="-1"><a class="header-anchor" href="#hashmap的扩容"><span>HashMap的扩容</span></a></h1><p>当 HashMap 数组长度不足时，会进行扩容，因为需要把元素拆分到新的数组中，所以需要重新计算 hash 值，jdk1.7中会需要重新计算哈希值，jdk1.8中已经进行优化，不再需要重新计算。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// oldCap：旧数组长度</span>
<span class="token comment">// e.hash：旧数组中节点的 hash 值</span>
e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前提条件分析：</p><ul><li><p>e.hash：数组中节点的 hash 值，计算方式， (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p></li><li><p>oldCap：旧数组长度，是2的n次幂的整数，1000…0</p></li><li><p>newCap：新数组的长度，2oldCap = oldCap &lt;&lt; 1，也是是2的n次幂的整数，1000…0</p></li><li><p>数组索引计算：(oldCap -1) &amp; e.hash，(2oldCap -1) &amp; e.hash</p></li><li><p>&amp; 与运算：两个同时为1，结果为1，否则为0</p></li></ul><p>分析：e.hash &amp; oldCap</p><ul><li><p>等于 0 ，索引位置不变</p></li><li><p>不等于 0 ，增加扩容的长度</p></li></ul><p><img src="`+l+'" alt="image-20230916101657726"></p>',8),i=[n];function h(o,c){return s(),e("div",null,i)}const m=a(t,[["render",h],["__file","HashMap的扩容.html.vue"]]),r=JSON.parse('{"path":"/java/base/HashMap%E7%9A%84%E6%89%A9%E5%AE%B9.html","title":"HashMap的扩容","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1694847225000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"java/base/HashMap的扩容.md"}');export{m as comp,r as data};
