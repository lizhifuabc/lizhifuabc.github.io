import{_ as a,r as e,o as t,c as l,b as s,e as i,d as o,a as p}from"./app-oJgUVX7T.js";const r={},c=s("h1",{id:"redis官方文档",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#redis官方文档"},[s("span",null,"Redis官方文档")])],-1),d={href:"https://redis.io/docs/manual/patterns/distributed-locks/",target:"_blank",rel:"noopener noreferrer"},u=p(`<h2 id="分布式锁的设计原则" tabindex="-1"><a class="header-anchor" href="#分布式锁的设计原则"><span>分布式锁的设计原则</span></a></h2><ol><li><p><strong>互斥</strong>（安全性）：在任何给定时刻，只有一个客户端可以持有锁。</p></li><li><p><strong>无死锁</strong>（有效性）：超时机制，即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；</p></li><li><p><strong>容错性</strong>（有效性）：只要大多数 Redis 节点都启动，客户端就可以获取和释放锁。</p></li><li><p><strong>同源性</strong>：A加的锁，不能被B解锁</p></li><li><p><strong>非阻塞</strong>：获取不到锁，不能无限期等待；</p></li><li><p><strong>高性能</strong>：加锁解锁是高性能的</p></li></ol><h2 id="锁定到单个实例" tabindex="-1"><a class="header-anchor" href="#锁定到单个实例"><span>锁定到单个实例</span></a></h2><p><strong>加锁</strong>：</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code>SET resource_name my_random_value NX PX <span class="token number">30000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol><li>resource_name：本次业务有关的id。</li><li>my_random_value：一串随机值，必须保证全局唯一。</li><li>NX：当且仅当key不存在时，返回执行成功，否则执行失败。</li><li>PX：30秒后，key将被自动删除。</li></ol><p>执行命令后返回成功，表明服务成功的获得了锁。</p><p><strong>重试 + 重试间隔</strong>：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> retryTimes<span class="token operator">--</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解锁</strong>：采用lua脚本</p><p>在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。如果贸然使用服务A持有的key来删除锁，则会误将服务B的锁释放掉。</p><div class="language-lua line-numbers-mode" data-ext="lua" data-title="lua"><pre class="language-lua"><code><span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">==</span>ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>
	<span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;del&quot;</span><span class="token punctuation">,</span> KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
	<span class="token keyword">return</span> <span class="token number">0</span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="基于redlock实现分布式锁" tabindex="-1"><a class="header-anchor" href="#基于redlock实现分布式锁"><span>基于RedLock实现分布式锁</span></a></h2><p>假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:</p><ol><li>客户端获取当前时间戳，单位: 毫秒</li><li>服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。</li><li>客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。</li><li>只要有其它服务创建过分布式锁，那么当前服务就必须轮寻尝试获取锁</li></ol><h2 id="redisson" tabindex="-1"><a class="header-anchor" href="#redisson"><span>Redisson</span></a></h2><ol><li>redisson所有指令都通过lua脚本执行，保证了操作的原子性</li><li>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</li><li>redisson支持Redlock的实现方式。</li></ol><p>执行流程：</p><ol><li>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</li><li>线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</li></ol><blockquote><p>参考文章</p><p>https://pdai.tech/md/arch/arch-z-lock.html</p></blockquote>`,20);function k(m,h){const n=e("ExternalLinkIcon");return t(),l("div",null,[c,s("p",null,[s("a",d,[i("Distributed Locks with Redis | Redis"),o(n)])]),u])}const g=a(r,[["render",k],["__file","Redis官方文档.html.vue"]]),b=JSON.parse('{"path":"/design/distributed/Redis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.html","title":"Redis官方文档","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"分布式锁的设计原则","slug":"分布式锁的设计原则","link":"#分布式锁的设计原则","children":[]},{"level":2,"title":"锁定到单个实例","slug":"锁定到单个实例","link":"#锁定到单个实例","children":[]},{"level":2,"title":"基于RedLock实现分布式锁","slug":"基于redlock实现分布式锁","link":"#基于redlock实现分布式锁","children":[]},{"level":2,"title":"Redisson","slug":"redisson","link":"#redisson","children":[]}],"git":{"updatedTime":1711264111000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/distributed/Redis官方文档.md"}');export{g as comp,b as data};
