import{_ as e,o as t,c as a,a as h}from"./app-oJgUVX7T.js";const n={},s=h('<h1 id="oauth常见问题" tabindex="-1"><a class="header-anchor" href="#oauth常见问题"><span>OAuth常见问题</span></a></h1><h2 id="前后端分离-登录页面和授权确认页面" tabindex="-1"><a class="header-anchor" href="#前后端分离-登录页面和授权确认页面"><span>前后端分离：登录页面和授权确认页面</span></a></h2><p>问题：</p><ol><li>OAuth 2 授权的时候会302重定向到授权服务器提供的登录页面和授权确认页面。</li></ol><p>原因：</p><ol><li>OAuth2客户端和授权服务器之间并不是一个完全信任的关系。</li></ol><p>例如现在智能门锁已经很普及了，一般都会有临时密码，而不是告诉访客实际密码。</p><p>ajax无法安全地处理OAuth2授权流程中的302重定向问题，这也是一个技术问题。</p><h2 id="常用场景" tabindex="-1"><a class="header-anchor" href="#常用场景"><span>常用场景</span></a></h2><p>OAuth2主要用于API授权，是跨API服务之间授权的解决方案。</p><ol><li>单点登录（SSO）</li><li>微服务之间的授权鉴权</li><li>API开放平台等场景。</li></ol><h2 id="密码模式为什么被废除" tabindex="-1"><a class="header-anchor" href="#密码模式为什么被废除"><span>密码模式为什么被废除</span></a></h2><p>OAuth2.1中密码模式被移除，包括OAuth0、okta等知名三方授权服务机构都对密码模式进行了移除处理。</p><p>密码模式诞生的时候，像React、Vue这种单页应用还没有兴起，甚至连框架都还没有呢。它更像一种为了解决遗留问题而采用的过渡方案。在传统应用中，用户习惯了把密码直接交给客户端换取资源访问权限，而不是跳来跳去去拉授权、确认授权。OAuth2诞生之初为了让用户从传统思维中慢慢转变过来就设计了这种模式。 它打破了委托授权的模式，降低了OAuth2的安全性。</p><h2 id="微服务是否可以不使用oauth2" tabindex="-1"><a class="header-anchor" href="#微服务是否可以不使用oauth2"><span>微服务是否可以不使用OAuth2</span></a></h2><p>可以，OAuth2只不过是目前微服务访问控制的解决方案之一，并不是唯一选项。</p><h2 id="资源服务器" tabindex="-1"><a class="header-anchor" href="#资源服务器"><span>资源服务器</span></a></h2><p>只要包含了需要OAuth2客户端携带access_token访问的资源接口的服务器都可以认为是资源服务器，包括OAuth2客户端、OAuth2授权服务器都可以根据业务和架构承担资源服务器的功能。从用户（资源所有者）角度来说，存放用户可以授权的资源接口的服务器都可以是资源服务器。资源服务器可以对访问令牌access_token进行解码、校验，并确定本次请求是否合规。</p><h2 id="客户端认证是什么" tabindex="-1"><a class="header-anchor" href="#客户端认证是什么"><span>客户端认证是什么</span></a></h2><p>confidential类型的OAuth2客户端虽然在OAuth2授权服务器注册，它们要根据一些策略（Client Authentication Method）来向授权服务器证明自己是合法的客户端。这样它们才能调用一些OAuth2规定的端点，比如/oauth2/token令牌端点、/oauth2/revoke令牌撤销端点等等。关于OAuth2客户端认证的细节可以参考OAuth2客户端认证过滤器详解。</p><h2 id="客户端能否做用户认证" tabindex="-1"><a class="header-anchor" href="#客户端能否做用户认证"><span>客户端能否做用户认证</span></a></h2><p>OAuth2本身并没有定义用户如何向OAuth2客户端认证身份，这里要和授权服务器上的用户认证区别开来。OAuth2客户端在完成授权时可以拿到授权凭据，但是并不能直接拿到用户信息，如果授权服务器提供了获取用户信息的资源接口，OAuth2客户端可以通过该接口尝试获取用户信息用来表明用户的身份，这取决于用户是否授权了OAuth2客户端这样做。OIDC 1.0补充定义了OAuth2客户端对用户进行认证的细节流程。</p><h2 id="scope是什么" tabindex="-1"><a class="header-anchor" href="#scope是什么"><span>scope是什么</span></a></h2><p>OAuth2是一个授权框架，授权自然要划定一个范围（scope），以保证OAuth2客户端在既定的范围内行事而不越界。它起到的作用和RBAC中的role其实类似，都是用来限制资源的访问权限的。role针对的是资源拥有者（Resource Owner），而scope针对的是OAuth2客户端。当然有一个例外openid，这个是OIDC 1.0的标识，算一个关键字。</p><h2 id="access-token和refresh-token应该直接返回给前端吗" tabindex="-1"><a class="header-anchor" href="#access-token和refresh-token应该直接返回给前端吗"><span>access_token和refresh_token应该直接返回给前端吗</span></a></h2><p>能不能返回给前端取决于这个前端是不是直接在授权服务器的OAuth2客户端，如果不是，就不能持有access_token和refresh_token，access_token和refresh_token的签发目标只能是OAuth2客户端。如果暴露面放开，则很容易被盗用。</p><h2 id="非oauth2客户端的客户端应用既然不能直接持有access-token和refresh-token的话-应该如何获取授权状态" tabindex="-1"><a class="header-anchor" href="#非oauth2客户端的客户端应用既然不能直接持有access-token和refresh-token的话-应该如何获取授权状态"><span>非OAuth2客户端的客户端应用既然不能直接持有access_token和refresh_token的话，应该如何获取授权状态</span></a></h2><p>当授权成功后，令牌和用户客户端侧可以借助于session或者cookie进行一个映射，当然也可以考虑计算出一个不透明令牌（ Opaque Token ）映射，具体根据业务考量。</p><h2 id="客户端为什么分为public和confidential两种类型-分别是什么场景" tabindex="-1"><a class="header-anchor" href="#客户端为什么分为public和confidential两种类型-分别是什么场景"><span>客户端为什么分为public和confidential两种类型，分别是什么场景</span></a></h2><p>相关定义参见rfc6749#section-2.1， 根据OAuth2客户端自身是否有能力维护客户端凭据（client credentials）的私密性，是否能安全地通过授权服务器对客户端的资质进行认证将OAuth2客户端分为机密客户端和公共客户端。大部分的后端数据服务都应该被注册为机密客户端；无法保障自身凭据安全的都应该被注册为公共客户端，公共客户端是没有client_sercet的，直接注册到OAuth2授权服务器的执行客户端，不通过后端应用进行访问令牌中继的都是公共客户端，特定场景需要直连授权服务器的Web应用、移动应用都属于这一类。</p><h2 id="什么是oauth2客户端" tabindex="-1"><a class="header-anchor" href="#什么是oauth2客户端"><span>什么是OAuth2客户端</span></a></h2><p>在OAuth2授权服务器上注册为客户端，并获得专属client_id标识的才是OAuth2客户端。</p><p>安卓应用、IOS应用、Web前端等客户端应用也要遵循这个原则，它们本身注册到OAuth2授权服务器才能成为OAuth2客户端，否则就不是OAuth2客户端，必须是它们本身，而不是支撑它们的后端服务。</p>',33),l=[s];function c(i,o){return t(),a("div",null,l)}const u=e(n,[["render",c],["__file","OAuth常见问题.html.vue"]]),p=JSON.parse('{"path":"/design/OAuth/OAuth%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html","title":"OAuth常见问题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"前后端分离：登录页面和授权确认页面","slug":"前后端分离-登录页面和授权确认页面","link":"#前后端分离-登录页面和授权确认页面","children":[]},{"level":2,"title":"常用场景","slug":"常用场景","link":"#常用场景","children":[]},{"level":2,"title":"密码模式为什么被废除","slug":"密码模式为什么被废除","link":"#密码模式为什么被废除","children":[]},{"level":2,"title":"微服务是否可以不使用OAuth2","slug":"微服务是否可以不使用oauth2","link":"#微服务是否可以不使用oauth2","children":[]},{"level":2,"title":"资源服务器","slug":"资源服务器","link":"#资源服务器","children":[]},{"level":2,"title":"客户端认证是什么","slug":"客户端认证是什么","link":"#客户端认证是什么","children":[]},{"level":2,"title":"客户端能否做用户认证","slug":"客户端能否做用户认证","link":"#客户端能否做用户认证","children":[]},{"level":2,"title":"scope是什么","slug":"scope是什么","link":"#scope是什么","children":[]},{"level":2,"title":"access_token和refresh_token应该直接返回给前端吗","slug":"access-token和refresh-token应该直接返回给前端吗","link":"#access-token和refresh-token应该直接返回给前端吗","children":[]},{"level":2,"title":"非OAuth2客户端的客户端应用既然不能直接持有access_token和refresh_token的话，应该如何获取授权状态","slug":"非oauth2客户端的客户端应用既然不能直接持有access-token和refresh-token的话-应该如何获取授权状态","link":"#非oauth2客户端的客户端应用既然不能直接持有access-token和refresh-token的话-应该如何获取授权状态","children":[]},{"level":2,"title":"客户端为什么分为public和confidential两种类型，分别是什么场景","slug":"客户端为什么分为public和confidential两种类型-分别是什么场景","link":"#客户端为什么分为public和confidential两种类型-分别是什么场景","children":[]},{"level":2,"title":"什么是OAuth2客户端","slug":"什么是oauth2客户端","link":"#什么是oauth2客户端","children":[]}],"git":{"updatedTime":1704446575000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/OAuth/OAuth常见问题.md"}');export{u as comp,p as data};
