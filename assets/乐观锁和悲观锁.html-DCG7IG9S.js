import{_ as e,o as a,c as i,a as l}from"./app-oJgUVX7T.js";const s="/assets/image-20230905215431906-DPj-bGkz.png",t="/assets/image-20230905215447878-7hHpQpzf.png",n={},c=l('<h1 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁"><span>乐观锁和悲观锁</span></a></h1><p>一句话：线程是否需要锁住资源。</p><h2 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁"><span>悲观锁</span></a></h2><ul><li>在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>Java中，synchronized关键字和Lock的实现类都是悲观锁。</li></ul><p><img src="'+s+'" alt="image-20230905215431906"></p><h2 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h2><ul><li>使⽤数据时不会有别的线程修改数据，所以不会添加锁。</li><li>更新数据的时候去判断之前有没有别的线程更新了这个数据。</li><li>如果这个数据没有被更新，当前线程将⾃⼰修改的数据成功写⼊。</li><li>如果数据已经被其他线程更新，则根据不同的实现⽅式执⾏不同的操作（例如报错或者⾃动重试）。</li><li>Java中是通过使⽤⽆锁编程来实现，最常采⽤的是CAS算法，Java原⼦类中的递增操作就通过CAS⾃旋实现的。</li></ul><p><img src="'+t+'" alt="image-20230905215447878"></p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><ul><li>悲观锁适合 **写&gt;读 **的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合 **读&gt;写 **的场景，不加锁的特点能够使其读操作的性能⼤幅提升。</li></ul>',10),r=[c];function h(o,d){return a(),i("div",null,r)}const _=e(n,[["render",h],["__file","乐观锁和悲观锁.html.vue"]]),m=JSON.parse('{"path":"/design/codedesign/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.html","title":"乐观锁和悲观锁","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[]},{"level":2,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"updatedTime":1694267248000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/codedesign/乐观锁和悲观锁.md"}');export{_ as comp,m as data};
