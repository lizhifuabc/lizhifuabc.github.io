import{_ as n,o as s,c as a,a as t}from"./app-oJgUVX7T.js";const e={},l=t(`<h1 id="redis过期策略" tabindex="-1"><a class="header-anchor" href="#redis过期策略"><span>Redis过期策略</span></a></h1><p><strong>定期删除</strong>：Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除</p><p><strong>惰性删除</strong>：获取某个 key 的时候，Redis 会检查一下 ，这个 key 如果设置了过期时间那么是否过期了？如果过期了此时就会删除，不会给你返回任何东西。</p><p><strong>内存淘汰机制</strong>： 当Redis的内存使用达到限制时：</p><ul><li>noeviction：新写入操作会报错（<strong>很少使用，因为无法预估</strong>）。</li><li>allkeys-lru：移除最近最少使用的 key（<strong>最常用</strong>）。</li><li>allkeys-random：在键空间中，随机移除某个 key。（<strong>很少使用</strong>）</li><li>volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的 key。</li><li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key。</li><li>volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li></ul><h2 id="lru算法-最近最少使用" tabindex="-1"><a class="header-anchor" href="#lru算法-最近最少使用"><span>LRU算法：最近最少使用</span></a></h2><p>LRU（Least Recently Used）算法是一种经典的缓存替换策略，它的核心思想是优先淘汰最近最少使用的数据，以便为新数据腾出空间。在数据缓存场景中，LRU算法能够保留热门数据，从而提高缓存的命中率。</p><p>LRU算法的原理非常直观：当缓存空间满了，系统会优先淘汰最久未被访问的数据。这个策略的背后思想是，如果某个数据在最近一段时间内没有被访问，那么它在未来也可能不会被访问。这种替换策略有助于保持缓存中的数据是<code>热数据</code>，即最近被频繁访问的数据。</p><p>优点：</p><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>适用于热数据</td><td>LRU算法保留了最近最常访问的数据，因此非常适用于具有明显访问热点的场景。</td></tr><tr><td>简单有效</td><td>LRU算法的实现相对简单，不需要复杂的计算和维护。</td></tr></tbody></table><p>限制：</p><table><thead><tr><th>限制</th><th>描述</th></tr></thead><tbody><tr><td>周期性访问</td><td>LRU算法可能会因为数据的周期性访问而导致不必要的数据替换，特别是在某些特殊业务场景中。</td></tr><tr><td>缓存污染</td><td>LRU算法容易受到突发的大量访问影响，可能导致缓存中的“热·数据被淘汰，从而影响缓存效果。</td></tr></tbody></table><h3 id="基于-linkedhashmap-的lru" tabindex="-1"><a class="header-anchor" href="#基于-linkedhashmap-的lru"><span>基于 LinkedHashMap 的LRU</span></a></h3><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRU</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/**
     * 传递进来最多能缓存多少数据
     *
     * <span class="token keyword">@param</span> <span class="token parameter">capacity</span> 缓存大小
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 如果map中的数据量大于设定的最大容量，返回true，再新加入对象时删除最老的数据
     *
     * <span class="token keyword">@param</span> <span class="token parameter">eldest</span> 最老的数据项
     * <span class="token keyword">@return</span> true则移除最老的数据
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当 map中的数据量大于指定的缓存个数的时候，自动移除最老的数据</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="lfu算法-最不经常使用" tabindex="-1"><a class="header-anchor" href="#lfu算法-最不经常使用"><span>LFU算法：最不经常使用</span></a></h2><p>LFU（Least Frequently Used）算法是一种与LRU相似的缓存替换策略，它的核心思想是优先淘汰最不经常使用的数据，以便为新数据腾出空间。在某些特定场景下，LFU算法能够更好地适应数据访问模式的变化。</p><p>优点</p><table><thead><tr><th>优点</th><th>描述</th></tr></thead><tbody><tr><td>适用于频繁刷新</td><td>LFU算法能够优先保留频繁被刷新的数据，适合某些周期性访问的场景。</td></tr><tr><td>对数据热度变化敏感</td><td>相比于LRU算法，LFU算法更能适应数据访问模式的变化，能够更好地反映数据的热度。</td></tr></tbody></table><p>限制</p><table><thead><tr><th>限制</th><th>描述</th></tr></thead><tbody><tr><td>计算复杂性</td><td>LFU算法需要维护数据的访问频率记录，这可能导致一定的计算复杂性，特别是在大规模数据场景下。</td></tr><tr><td>冷启动问题</td><td>对于刚开始访问的数据，由于没有足够的访问频率信息，LFU算法可能难以做出合适的替换决策。</td></tr></tbody></table><h2 id="random-replacement-随机替换" tabindex="-1"><a class="header-anchor" href="#random-replacement-随机替换"><span>Random Replacement（随机替换）</span></a></h2><p>随机替换是一种简单但有效的缓存策略。与LRU和LFU不同，随机替换策略不考虑数据的访问时间或频率，而是随机选择要替换的数据。尽管这听起来不太智能，但在某些场景下，随机替换策略表现出意外的优势。</p><p>随机替换的核心思想是，每次需要替换数据时，从缓存中随机选择一条数据进行替换。虽然这种策略没有考虑数据的热度或频率，但在一些特殊情况下，随机替换能够避免特定数据被频繁淘汰，从而维持一定的数据多样性。</p><h2 id="least-recently-used-with-sampling-lrus" tabindex="-1"><a class="header-anchor" href="#least-recently-used-with-sampling-lrus"><span>Least Recently Used with Sampling（LRUS）</span></a></h2><p>除了传统的LRU算法，还存在一种改进的版本，即LRUS（Least Recently Used with Sampling）算法。LRUS算法通过周期性的采样来记录数据的访问情况，从而更好地估计最近使用的数据，减少了LRU算法中的“冷启动·问题。</p><p>LRUS算法引入了采样机制，通过周期性地记录一部分数据的访问情况，从而更准确地判断哪些数据是热数据，哪些是冷数据。与传统的LRU算法不同，LRUS算法能够更好地适应数据访问模式的变化，提高数据缓存的命中率。</p><h2 id="实例" tabindex="-1"><a class="header-anchor" href="#实例"><span>实例</span></a></h2><p><strong>商品列表页</strong>：由于商品列表页中的商品信息经常变动，可以选择LRU（最近最少使用）或者随机替换策略。这样可以保留最近的商品数据，提高页面加载速度。</p><p><strong>商品详情页</strong>：商品详情页的数据相对稳定，适合选择LFU（最不经常使用）策略。这样可以保留频繁访问的商品详情数据，提高页面响应速度。</p><p><strong>购物车页</strong>：购物车页的数据与用户关联紧密，可以选择LRU（最近最少使用）或者LRUS（最近最少用于采样）策略。这样可以保留最近被访问的购物车数据，提供更好的用户体验。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在实际应用中，选择合适的缓存策略是至关重要的。根据不同的业务场景和数据访问模式，我们可以灵活地选择LRU、LFU、LRUS、随机替换等缓存策略。同时，还可以根据实际需要动态地调整缓存大小，以达到最佳的性能与资源利用率的平衡。</p><p><strong>分析数据访问模式</strong>：在选择缓存策略之前，首先需要详细分析数据的访问模式。哪些数据被频繁访问？哪些数据变化较少？根据这些信息，选择适合的缓存策略。</p><p><strong>选择合适的算法</strong>：根据业务需求，选择合适的缓存算法。LRU适用于保留最近访问的数据，LFU适用于保留最频繁访问的数据，而LRUS则更好地应对访问模式的变化。</p><p><strong>监控与优化</strong>：缓存策略不是一成不变的，需要不断监控数据访问情况，优化缓存大小和策略。通过监控缓存的命中率和利用率，可以动态地做出调整。</p><p><strong>灵活应用</strong>：不同的业务模块可能需要不同的缓存策略。根据实际情况，可以在系统中采用多种缓存策略，以最大程度地提升性能。</p><blockquote><p>https://juejin.cn/post/7274146202496614458</p></blockquote>`,37),p=[l];function i(c,o){return s(),a("div",null,p)}const r=n(e,[["render",i],["__file","Redis过期策略.html.vue"]]),u=JSON.parse('{"path":"/database/nosql/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5.html","title":"Redis过期策略","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"LRU算法：最近最少使用","slug":"lru算法-最近最少使用","link":"#lru算法-最近最少使用","children":[{"level":3,"title":"基于 LinkedHashMap 的LRU","slug":"基于-linkedhashmap-的lru","link":"#基于-linkedhashmap-的lru","children":[]}]},{"level":2,"title":"LFU算法：最不经常使用","slug":"lfu算法-最不经常使用","link":"#lfu算法-最不经常使用","children":[]},{"level":2,"title":"Random Replacement（随机替换）","slug":"random-replacement-随机替换","link":"#random-replacement-随机替换","children":[]},{"level":2,"title":"Least Recently Used with Sampling（LRUS）","slug":"least-recently-used-with-sampling-lrus","link":"#least-recently-used-with-sampling-lrus","children":[]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1694337389000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"database/nosql/Redis过期策略.md"}');export{r as comp,u as data};
