import{_ as a,o as t,c as e,a as i}from"./app-oJgUVX7T.js";const r="/assets/image-20230916111128660-CAu9NCqk.png",s="/assets/ArrayList_add-Cnitt-8x.png",l={},n=i('<h1 id="java集合arraylist" tabindex="-1"><a class="header-anchor" href="#java集合arraylist"><span>Java集合ArrayList</span></a></h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。</p><ul><li>未实现同步，其余跟<em>Vector</em>大致相同。</li><li>每个<em>ArrayList</em>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。</li><li>当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。</li></ul><p><img src="'+r+'" alt="image-20230916111128660"></p><h2 id="自动扩容" tabindex="-1"><a class="header-anchor" href="#自动扩容"><span>自动扩容</span></a></h2><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容。</p><p>数组扩容通过ensureCapacity(int minCapacity)方法来实现，实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p><p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。</p><ul><li>可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。</li><li>根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</li></ul><p><img src="'+s+'" alt="ArrayList_add"></p><h2 id="快速失败机制" tabindex="-1"><a class="header-anchor" href="#快速失败机制"><span>快速失败机制</span></a></h2><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p><blockquote><p>https://pdai.tech/md/interview/x-interview.html#_2-1-collection</p></blockquote>',13),c=[n];function o(p,m){return t(),e("div",null,c)}const h=a(l,[["render",o],["__file","Java集合ArrayList.html.vue"]]),_=JSON.parse('{"path":"/java/base/Java%E9%9B%86%E5%90%88ArrayList.html","title":"Java集合ArrayList","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"自动扩容","slug":"自动扩容","link":"#自动扩容","children":[]},{"level":2,"title":"快速失败机制","slug":"快速失败机制","link":"#快速失败机制","children":[]}],"git":{"updatedTime":1694847225000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"java/base/Java集合ArrayList.md"}');export{h as comp,_ as data};
