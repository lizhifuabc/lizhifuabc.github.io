import{_ as n,o as s,c as a,a as e}from"./app-oJgUVX7T.js";const l="/assets/image-20230910220607170-BJQTWGVL.png",p="/assets/image-20230910220719315-CPS3ZbWQ.png",i={},t=e('<h1 id="mysql分表分库-分库分表聚合查询" tabindex="-1"><a class="header-anchor" href="#mysql分表分库-分库分表聚合查询"><span>MySQL分表分库-分库分表聚合查询</span></a></h1><p>在分库分表的数据库系统中，通常会将数据按照一定的规则分散存储在不同的数据库或表中。这些规则通常基于数据中的某个字段，称为分片字段。例如，可以按照用户 ID 对用户数据进行分库分表，每个用户的数据都存储在不同的数据库或表中。</p><p>如果进行的是非分片字段查询，即查询条件中不包含分片字段，那么数据库系统将不能根据分库分表规则确定查询的目标数据库或表。在这种情况下，数据库系统通常会执行全库或全表扫描，查询所有的数据库或表，这样可能会导致性能问题。</p><h2 id="分库分表聚合查询常见解决方案" tabindex="-1"><a class="header-anchor" href="#分库分表聚合查询常见解决方案"><span>分库分表聚合查询常见解决方案</span></a></h2><p><img src="'+l+`" alt="image-20230910220607170"></p><h2 id="union-all" tabindex="-1"><a class="header-anchor" href="#union-all"><span>union all</span></a></h2><p>UNION ALL 是 SQL 语言中用于合并多个查询结果集的语法。它与 UNION 的区别在于，UNION ALL 会将多个查询结果集完整地合并在一起，而 UNION 会在合并之前对查询结果集进行去重处理。</p><p>UNION ALL 语法的一般形式如下：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table1
<span class="token keyword">WHERE</span> condition1

<span class="token keyword">UNION</span> <span class="token keyword">ALL</span>

<span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">FROM</span> table2
<span class="token keyword">WHERE</span> condition2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用非分片字段查询时，通过全局扫描的形式返回所有的结果集。</p><h2 id="基因法-融合法" tabindex="-1"><a class="header-anchor" href="#基因法-融合法"><span>基因法(融合法)</span></a></h2><p>分库分表基因法是一种数据库系统中分库分表的策略。它是通过将每个数据库或表看作一个基因，并通过组合基因来决定数据存储位置的方法。</p><p>例如，在基因法分库分表系统中，可以将每个数据库或表都赋予一个唯一的基因编码，然后将每条数据的基因编码与数据库或表的基因编码进行匹配，来决定该数据存储在哪个数据库或表中。</p><p>使用基因法分库分表的优点在于，可以通过更改基因编码的对应关系来调整数据分布情况，而不需要重新进行数据迁移。这可以帮助数据库系统更加灵活地应对数据分布变化，提高系统的稳定性和性能。</p><p>基因法：<strong>对一个数取余2的n次方，那么余数就是这个数的二进制的最后n位数。</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>用户的uid为<span class="token number">9</span><span class="token punctuation">,</span> 那么  <span class="token number">9</span><span class="token operator">%</span><span class="token number">4</span>
<span class="token number">9</span>			<span class="token number">4</span>
<span class="token number">0001</span> <span class="token number">0000</span>	<span class="token number">0100</span>
按照最后两位作为分库因子 <span class="token number">00</span>

订单表 <span class="token function">oid</span><span class="token punctuation">(</span><span class="token number">64</span>位<span class="token punctuation">)</span> 使用分布式<span class="token constant">ID</span>生成<span class="token number">62</span>位<span class="token punctuation">(</span>如雪花算法<span class="token punctuation">)</span> <span class="token operator">+</span> 分库因子

按照上述方法<span class="token punctuation">,</span>可以保证同一个用户的所有订单<span class="token punctuation">,</span>都落在同一个库上<span class="token punctuation">,</span>可以通过用户uid<span class="token operator">%</span><span class="token number">4</span>定位库<span class="token punctuation">,</span>也可以通过oid<span class="token operator">%</span><span class="token number">4</span>定位到库
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="索引表-关联表-法" tabindex="-1"><a class="header-anchor" href="#索引表-关联表-法"><span>索引表（关联表）法</span></a></h2><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> idx_orderid_userid （
  order_id <span class="token keyword">bigint</span>
  user_id <span class="token keyword">bigint</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>order_id<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+p+`" alt="image-20230910220719315"></p><p>原始SQL：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_ORDER <span class="token keyword">WHERE</span> order_id <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>拆分后的SQL：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># step 1</span>
<span class="token keyword">SELECT</span> user_id <span class="token keyword">FROM</span> idx_orderid_userid 
<span class="token keyword">WHERE</span> order_id <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment"># step 2</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> T_ORDER 
<span class="token keyword">WHERE</span> user_id <span class="token operator">=</span> ? <span class="token operator">AND</span> order_id <span class="token operator">=</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不论有多少个分片，也只需要查询 2个分片的信息，这样 SQL 的查询性能可以得到极大的提升。</p><h2 id="冗余数据法" tabindex="-1"><a class="header-anchor" href="#冗余数据法"><span>冗余数据法</span></a></h2><p>一条数据保存多份。</p><p>也就是说各分个的，原来只有一个分片字段，再增加一个分片字段。</p>`,27),o=[t];function c(d,r){return s(),a("div",null,o)}const k=n(i,[["render",c],["__file","MySQL分表分库-分库分表聚合查询.html.vue"]]),m=JSON.parse('{"path":"/database/mysql/MySQL%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2.html","title":"MySQL分表分库-分库分表聚合查询","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"分库分表聚合查询常见解决方案","slug":"分库分表聚合查询常见解决方案","link":"#分库分表聚合查询常见解决方案","children":[]},{"level":2,"title":"union all","slug":"union-all","link":"#union-all","children":[]},{"level":2,"title":"基因法(融合法)","slug":"基因法-融合法","link":"#基因法-融合法","children":[]},{"level":2,"title":"索引表（关联表）法","slug":"索引表-关联表-法","link":"#索引表-关联表-法","children":[]},{"level":2,"title":"冗余数据法","slug":"冗余数据法","link":"#冗余数据法","children":[]}],"git":{"updatedTime":1694763025000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"database/mysql/MySQL分表分库-分库分表聚合查询.md"}');export{k as comp,m as data};
