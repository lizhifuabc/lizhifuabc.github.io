import{_ as e,o as l,c as i,a}from"./app-oJgUVX7T.js";const t="/assets/image-20240515153950473-6qD-0Nat.png",s={},c=a('<h1 id="高并发下防止重复下单" tabindex="-1"><a class="header-anchor" href="#高并发下防止重复下单"><span>高并发下防止重复下单</span></a></h1><p><img src="'+t+'" alt="image-20240515153950473"></p><h2 id="幂等性" tabindex="-1"><a class="header-anchor" href="#幂等性"><span>幂等性</span></a></h2><p>一个接口如果幂等，不管被调多少次，只要参数不变，结果也不变。</p><p>核心流程：一锁、二判、三更新。</p><h2 id="主要解决方案" tabindex="-1"><a class="header-anchor" href="#主要解决方案"><span>主要解决方案</span></a></h2><ul><li>提交订单按钮置灰 <ul><li>可以防止重复点击提交按钮造成的重复提交问题</li><li>前进后退操作，或者F5刷新页面等问题并不能得到解决</li></ul></li><li>请求唯一ID+数据库唯一索引约束 <ul><li>客户端在请求下单接口的时候，需要生成一个唯一的请求号</li><li>服务端拿这个请求号，判断是否重复请求</li></ul></li><li>reids分布式锁+请求唯一ID+数据库唯一索引约束 <ul><li>当用户进入订单提交界面的时候，调用后端获取请求唯一 ID，同时后端将请求唯一ID存储到<code>redis</code>中再返回给前端</li><li>当用户点击提交按钮时，后端检查这个请求唯一 ID 是否存在，如果不存在，提示错误信息；如果存在，继续后续检查流程</li><li>使用<code>redis</code>的分布式锁服务，对请求 ID 在限定的时间内进行加锁，如果加锁成功，继续后续流程；如果加锁失败，提示说明：服务正在处理，请勿重复提交</li><li>最后一步，如果加锁成功后，需要将锁手动释放掉，以免再次请求时，提示同样的信息；同时如果任务执行成功，需要将<code>redis</code>中的请求唯一 ID 清理掉</li></ul></li><li>reids分布式锁+token+数据库唯一索引约束 <ul><li>用户点击提交按钮，服务端接受到请求后，通过规则计算出本次请求唯一ID值；应用名+接口名+方法名+请求参数签名（请求header、body参数，取SHA1值）</li><li>使用<code>redis</code>的分布式锁服务，对请求 ID 在限定的时间内尝试进行加锁，如果加锁成功，继续后续流程；如果加锁失败，说明服务正在处理，请勿重复提交。</li><li>最后一步，如果加锁成功后，需要将锁手动释放掉，以免再次请求时，提示同样的信息。</li></ul></li></ul>',7),d=[c];function o(r,n){return l(),i("div",null,d)}const _=e(s,[["render",o],["__file","高并发下防止重复下单.html.vue"]]),p=JSON.parse('{"path":"/pay/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95.html","title":"高并发下防止重复下单","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"幂等性","slug":"幂等性","link":"#幂等性","children":[]},{"level":2,"title":"主要解决方案","slug":"主要解决方案","link":"#主要解决方案","children":[]}],"git":{"updatedTime":1715766109000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"pay/高并发下防止重复下单.md"}');export{_ as comp,p as data};
