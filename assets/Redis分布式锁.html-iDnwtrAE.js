import{_ as s,o as n,c as e,a}from"./app-oJgUVX7T.js";const t={},i=a(`<h1 id="redis分布式锁" tabindex="-1"><a class="header-anchor" href="#redis分布式锁"><span>Redis分布式锁</span></a></h1><ol><li><strong>使用SETNX命令设置锁</strong>： <ul><li>使用Redis的<code>SETNX</code>（Set If Not Exists）命令来尝试在Redis中设置一个键值对，其中键表示要锁定的资源或操作，值可以是一个唯一的标识符，如请求者的标识符或随机生成的唯一标识符。</li><li>如果<code>SETNX</code>成功，表示锁定成功，返回1。如果键已存在，表示锁定失败，返回0。</li></ul></li><li><strong>设置锁的过期时间</strong>： <ul><li>为了避免死锁，必须为锁设置一个过期时间（锁的自动释放时间）。</li><li>使用Redis的<code>EXPIRE</code>或<code>PEXPIRE</code>命令为锁设置过期时间，以确保即使锁未被显式释放，也会在一定时间后自动释放。</li></ul></li><li><strong>释放锁</strong>： <ul><li>当进程完成对资源的访问时，应该使用<code>DEL</code>命令或<code>UNLINK</code>命令（在Redis 4.0之后的版本中可用）来删除锁，以释放资源并允许其他进程获得锁。</li></ul></li><li><strong>处理竞争条件</strong>： <ul><li>在使用<code>SETNX</code>命令时，要处理竞争条件，确保只有持有锁的进程才能释放锁。可以使用Lua脚本来原子性地检查键是否存在并删除它。</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> lockKey<span class="token punctuation">,</span> <span class="token class-name">String</span> lockValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 使用Lua脚本来原子性地检查并释放锁</span>
      <span class="token class-name">String</span> releaseScript <span class="token operator">=</span> 
          <span class="token string">&quot;if redis.call(&#39;GET&#39;, KEYS[1]) == ARGV[1] then &quot;</span> <span class="token operator">+</span>
          <span class="token string">&quot;   return redis.call(&#39;DEL&#39;, KEYS[1]) &quot;</span> <span class="token operator">+</span>
          <span class="token string">&quot;else &quot;</span> <span class="token operator">+</span>
          <span class="token string">&quot;   return 0 &quot;</span> <span class="token operator">+</span>
          <span class="token string">&quot;end&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>实现思路：</p><ol><li><p>获取锁的时候，使用setnx加锁，并使用expire命令为锁添加—个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。</p></li><li><p>获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p></li><li><p>释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。</p></li></ol><blockquote><p>实际当中，不会使用setNx去实现，因为太麻烦，要考虑死锁问题、释放锁问题。</p><p>一般会使用Redisson框架，专门来处理redis的分布式相关问题。</p></blockquote>`,7),l=[i];function o(c,d){return n(),e("div",null,l)}const r=s(t,[["render",o],["__file","Redis分布式锁.html.vue"]]),u=JSON.parse('{"path":"/design/distributed/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"Redis分布式锁","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1694156727000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/distributed/Redis分布式锁.md"}');export{r as comp,u as data};
