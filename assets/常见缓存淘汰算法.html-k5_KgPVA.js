import{_ as e,o as l,c as i,a}from"./app-oJgUVX7T.js";const t="/assets/image-20230910171944102-y-vOvRnn.png",c="/assets/image-20230910172006670-Cd3PM4YO.png",n={},s=a('<h1 id="常见缓存淘汰算法" tabindex="-1"><a class="header-anchor" href="#常见缓存淘汰算法"><span>常见缓存淘汰算法</span></a></h1><ul><li>FIFO：First in First out，先进先出</li><li>LRU：Least Recently Used，最近最久未使用算法</li><li>LFU：Least Frequently Used ，最近最少使用算法</li><li>W-TinyLFU：Window Tiny Least Frequently Used ，是对LFU的的优化和加强。</li></ul><h2 id="fifo算法" tabindex="-1"><a class="header-anchor" href="#fifo算法"><span>FIFO算法</span></a></h2><p>最简单、最公平的一种思想，如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</p><ul><li><p>get(key)：如果cache中存在该key，则返回对应的value值，否则，返回-1；</p></li><li><p>set(key,value)：</p><ul><li>如果cache中存在该key，则重置value值</li><li>如果不存在该key，则将该key插入到到cache中</li><li>若cache已满，则淘汰最早进入cache的数据</li></ul></li></ul><p>不足：</p><p>热点元素如果某段时间没有访问就会被放置到队列尾部，即使重新访问也依然在队列尾部，会被误删。</p><h2 id="lru算法" tabindex="-1"><a class="header-anchor" href="#lru算法"><span>LRU算法</span></a></h2><p>如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。</p><p>分布式缓存系统（如Redis, Memcached）中使用较多。</p><ul><li><p>set(key,value)：</p><ul><li>如果key不在cache中，则将该(key,value)插入cache中</li><li>如果cache已满，则必须把最近最久未使用的元素从cache中删除</li><li>如果key在cache中，则重置value的值</li></ul></li><li><p>get(key)：如果key在cache中，则返回对应的value值，否则返回-1</p></li></ul><p><img src="'+t+'" alt="image-20230910171944102"></p><p>不足点：</p><p>大量元素查询，此时数据就会被加载到缓存队列中，真正的热点元素存在被删除的风险。</p><h2 id="lfu算法" tabindex="-1"><a class="header-anchor" href="#lfu算法"><span>LFU算法</span></a></h2><p>如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</p><ul><li>set(key,value)： <ul><li>如果cache中存在该key，则重置value值；</li><li>如果不存在该key，则将该key插入到到cache中</li><li>若cache已满，则淘汰最少访问的数据</li></ul></li><li>get(key)：如果Cache中存在该key，则返回对应的value值，否则，返回-1；</li></ul><p><img src="'+c+'" alt="image-20230910172006670"></p><p>不足点：</p><p>如果突然一批数据被访问了上千万次，但是第二天这批数据就不再访问了，但是又由于之前秒杀活动导致这批数据的访问基数太过高，导致一直无法清空，所以会一直占用着本地缓存的空间。</p><h2 id="w-tinylfu算法" tabindex="-1"><a class="header-anchor" href="#w-tinylfu算法"><span>W-TinyLFU算法</span></a></h2><p>当一个数据进来的时候，会进行筛选比较，进入W-LRU窗口队列，以此应对流量突增，经过淘汰后进入过滤器，通过访问频率判决是否进入缓存。如果一个数据最近被访问的次数很低，那么被认为在未来被访问的概率也是最低的，当规定空间用尽的时候，会优先淘汰最近访问次数很低的数据；</p><ul><li>Count-Min Sketch 算法存储访问频率，节省空间；定期衰减操作，应对访问模式变化。可以认为是布隆过滤器的一种变种。</li><li>window-lru机制尽可能避免缓存污染的发生，在过滤器内部会进行筛选处理，避免低频数据置换高频数据。</li></ul><p>感兴趣的可以结合 Caffeine 的源码进行学习。</p>',24),p=[s];function h(u,r){return l(),i("div",null,p)}const d=e(n,[["render",h],["__file","常见缓存淘汰算法.html.vue"]]),f=JSON.parse('{"path":"/database/nosql/%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95.html","title":"常见缓存淘汰算法","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"FIFO算法","slug":"fifo算法","link":"#fifo算法","children":[]},{"level":2,"title":"LRU算法","slug":"lru算法","link":"#lru算法","children":[]},{"level":2,"title":"LFU算法","slug":"lfu算法","link":"#lfu算法","children":[]},{"level":2,"title":"W-TinyLFU算法","slug":"w-tinylfu算法","link":"#w-tinylfu算法","children":[]}],"git":{"updatedTime":1694337805000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"database/nosql/常见缓存淘汰算法.md"}');export{d as comp,f as data};
