import{_ as a,o as n,c as s,a as e}from"./app-oJgUVX7T.js";const t={},c=e(`<h1 id="java垃圾回收基础" tabindex="-1"><a class="header-anchor" href="#java垃圾回收基础"><span>Java垃圾回收基础</span></a></h1><h2 id="对象是否可被回收" tabindex="-1"><a class="header-anchor" href="#对象是否可被回收"><span>对象是否可被回收</span></a></h2><h3 id="引用计数算法" tabindex="-1"><a class="header-anchor" href="#引用计数算法"><span>引用计数算法</span></a></h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGC</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ReferenceCountingGC</span> objectA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ReferenceCountingGC</span> objectB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objectB<span class="token punctuation">;</span>
        objectB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objectA<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法"><span>可达性分析算法</span></a></h2><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h2 id="方法区的回收" tabindex="-1"><a class="header-anchor" href="#方法区的回收"><span>方法区的回收</span></a></h2>`,11),p=[c];function l(o,i){return n(),s("div",null,p)}const u=a(t,[["render",l],["__file","Java垃圾回收基础.html.vue"]]),d=JSON.parse('{"path":"/java/jvm/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%9F%BA%E7%A1%80.html","title":"Java垃圾回收基础","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"对象是否可被回收","slug":"对象是否可被回收","link":"#对象是否可被回收","children":[{"level":3,"title":"引用计数算法","slug":"引用计数算法","link":"#引用计数算法","children":[]}]},{"level":2,"title":"可达性分析算法","slug":"可达性分析算法","link":"#可达性分析算法","children":[]},{"level":2,"title":"方法区的回收","slug":"方法区的回收","link":"#方法区的回收","children":[]}],"git":{"updatedTime":1694074496000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"java/jvm/Java垃圾回收基础.md"}');export{u as comp,d as data};
