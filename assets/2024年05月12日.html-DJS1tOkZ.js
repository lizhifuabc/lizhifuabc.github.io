import{_ as e,o as a,c as l,a as t}from"./app-oJgUVX7T.js";const i={},c=t('<h1 id="_2024年05月12日" tabindex="-1"><a class="header-anchor" href="#_2024年05月12日"><span>2024年05月12日</span></a></h1><ul><li><p>Spring Bean 注册</p></li><li><p>Spring 三级缓存</p><ul><li><p>一级缓存这样存放成品 Bean，不能解决循环依赖的问题的。因为 A 的成品创建依赖于 B，B的成品创建又依赖于 A，当需要补全B的属性时 A 还是没有创建完，所以会出现死循环。</p></li><li><p>二级缓存用于存放半成品对象，继续创建，创建的半成品同样放到缓存中。</p></li><li><p>三级缓存主要是解决 Spring AOP 的特性。AOP 本身就是对方法的增强，是 <code>ObjectFactory&lt;?&gt;</code> 类型的 lambda 表达式，而 Spring 的原则又不希望将此类类型的 Bean 前置创建，所以要存放到三级缓存中处理。</p></li></ul></li><li><p>聊一下 ThreadLocal</p><ul><li><code>ThreadLocal</code> 底层采用的是数组结构存储数据。</li><li><code>new ThreadLocal&lt;&gt;().remove();</code> 操作。避免弱引用发生GC后，导致内存泄漏的问题。</li></ul></li></ul>',2),o=[c];function n(r,p){return a(),l("div",null,o)}const s=e(i,[["render",n],["__file","2024年05月12日.html.vue"]]),_=JSON.parse('{"path":"/Interview/2024%E5%B9%B405%E6%9C%8812%E6%97%A5.html","title":"2024年05月12日","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1715597425000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"Interview/2024年05月12日.md"}');export{s as comp,_ as data};
