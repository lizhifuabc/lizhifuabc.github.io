import{_ as n,o as s,c as a,a as t}from"./app-oJgUVX7T.js";const p="/assets/image-20230905164742777-CNLTB78Y.png",e="/assets/image-20230905164936434-DdqXrK5Y.png",l="/assets/image-20230905164925401-Cte2N6gv.png",i={},o=t('<h1 id="分库分表常见算法" tabindex="-1"><a class="header-anchor" href="#分库分表常见算法"><span>分库分表常见算法</span></a></h1><p>分库分表分片策略选择，主要考虑两个原则：</p><ol><li>当前业务是否真的需要分库分表，分库分表虽然可以减少单库单表的数据压力，处于一个良好的查询响应范围，但是带来的问题也比较多，比如事务，数据查询等等，所以我认为不到万不得已，不要进行分库分表。</li><li>既然已经决定了要进行分库分表，分库分表分片策略选择就比较重要。</li></ol><h2 id="哈希取模算法" tabindex="-1"><a class="header-anchor" href="#哈希取模算法"><span>哈希取模算法</span></a></h2><p>根据某一列的哈希值来拆分表，比如将用户的 email 按照哈希值来拆分表，以达到数据分布均匀的目的。hash(字段) mod 数据库实例数或子表数量，是最为常见的一种路由方式。</p><p><img src="'+p+`" alt="image-20230905164742777"></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ModTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 数量</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// hash值：返回一个数的绝对值</span>
        <span class="token keyword">long</span> hash <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hash <span class="token operator">%</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：</p><ol><li>数据均衡：哈希拆分可以将数据均衡地分布在不同的表中，避免某一个表数据量过大，从而导致性能问题。</li><li>横向扩展：当数据量增长时，可以通过增加新的表来进行横向扩展，而不需要进行纵向扩展。</li></ol><p>缺点：</p><ol><li>就是扩容麻烦，需要重新计算每一行数据对应的哈希值。</li><li>不适用于归档：哈希拆分没有考虑时间因素，因此无法将历史数据归档到单独的表中。</li></ol><h2 id="容量-时间-范围算法" tabindex="-1"><a class="header-anchor" href="#容量-时间-范围算法"><span>容量（时间）范围算法</span></a></h2><ul><li><p>按照范围拆分：根据某一列的值来拆分表，比如将 id 从 1 到 1000 的数据拆分到第一个数据库，将 id 从 1001 到 2000 的数据拆分到第二个数据库，依此类推。</p></li><li><p>时间拆分：根据时间来拆分表，比如将当月的数据拆分到当月的表中，将去年的数据拆分到去年的表中，依此类推。</p></li></ul><p><img src="`+e+'" alt="image-20230905164936434"></p><p>优点：</p><ol><li>方便进行横向扩展：当数据量增长时，可以通过增加新的表来进行横向扩展，而不需要进行纵向扩展。</li><li>规则简单，容易理解。</li><li>历史数据可以进行单独的归档。</li></ol><p>缺点：</p><ol><li>数据倾斜，数据热点可能存在于某个范围或者时间段中，数据库压力分摊不均匀</li></ol><h2 id="范围-取模算法" tabindex="-1"><a class="header-anchor" href="#范围-取模算法"><span>范围 + 取模算法</span></a></h2><p>将范围拆分和取模算法结合起来使用。</p><ol><li>将数据按照范围放到不同的数据库中。</li><li>取模运算，将数据分配到不同的数据表中。</li></ol><p><img src="'+l+'" alt="image-20230905164925401"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>分库分表是一种数据库设计技术，其目的是为了提高数据库的性能和扩展性。它通过将数据库的表拆分到多个数据库中来实现这一目的。</p><p>要根据实际的业务情况进行组合，例如省、市；男、女；年龄；等等都可以作为策略。</p><ul><li><strong>增加了系统的复杂性</strong>：分库分表会增加系统的复杂性，有时候需要额外的中间件（MyCat）来实现，并且需要在程序中额外处理分库分表的逻辑。分页、排序、跨节点联合查询等等问题。</li><li><strong>降低了事务的原子性</strong>：由于分库分表会将数据存储在多个数据库或表中，因此在一次事务中可能涉及多个数据库，降低了事务的原子性。如何解决跨库事务问题。</li><li><strong>对性能的影响不确定</strong>：分库分表并不是一定能提高性能，具体的性能提升取决于实际情况，如果没有正确地进行分库分表，可能会导致性能下降。</li><li><strong>需要进行数据迁移</strong>：如果需要扩展分库分表的范围，可能需要进行数据迁移，这会增加系统的复杂性和风险。</li></ul><p>总之，分库分表有一些优点，但同时也有一些缺点，在实际应用中需要谨慎考虑。</p>',27),c=[o];function u(r,d){return s(),a("div",null,c)}const m=n(i,[["render",u],["__file","分库分表常见算法.html.vue"]]),h=JSON.parse('{"path":"/design/distributed/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95.html","title":"分库分表常见算法","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"哈希取模算法","slug":"哈希取模算法","link":"#哈希取模算法","children":[]},{"level":2,"title":"容量（时间）范围算法","slug":"容量-时间-范围算法","link":"#容量-时间-范围算法","children":[]},{"level":2,"title":"范围 + 取模算法","slug":"范围-取模算法","link":"#范围-取模算法","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1693904827000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/distributed/分库分表常见算法.md"}');export{m as comp,h as data};
