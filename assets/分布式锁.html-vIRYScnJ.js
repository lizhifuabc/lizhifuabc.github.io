import{_ as n,o as s,c as a,a as e}from"./app-oJgUVX7T.js";const l={},t=e(`<h1 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁"><span>分布式锁</span></a></h1><p>分布式场景下，保证同一时刻对共享数据只能被一个应用的一个线程操作。用来保证共享数据的安全性和一致性。</p><p>常见实现方式：</p><ul><li>基于数据库实现</li><li>基于<code>ZooKeeper</code>实现</li><li>基于<code>Redis</code>实现</li></ul><h2 id="分布式锁特性" tabindex="-1"><a class="header-anchor" href="#分布式锁特性"><span>分布式锁特性</span></a></h2><ul><li>排他性：同一时刻只能有一个应用的一个线程可以执行加锁的方法，获取到锁。</li><li>高性能：分布式锁可能会有很多的服务器来获取，高性能的获取和释放，不能因为某一个分布式锁获取的服务不可用，导致所有服务都拿不到或释放锁，所以要满足高可用要求。</li><li>锁失效机制，防止死锁：假设某个应用获取到锁之后，一直没有来释放锁，可能服务本身已经挂掉了，不能一直不释放，导致其他服务一直获取不到锁。</li><li>可重入性：一个应用如果成功获取到锁之后，再次获取锁也可以成功</li><li>非堵塞：在某个服务来获取锁时，假设该锁已经被另一个服务获取，我们要能直接返回失败，不能一直等待。</li></ul><h2 id="基于数据库" tabindex="-1"><a class="header-anchor" href="#基于数据库"><span>基于数据库</span></a></h2><ul><li>利用数据库的唯一约束 UNIQUE KEY</li><li>排他锁 for update</li></ul><ol><li><p>排他性：具备</p></li><li><p>高可用：多机部署，主从同步、主备切换等。</p></li><li><p>高性能：没有 nosql 数据库并发性能高。</p></li><li><p>失效机制：单独增加定时任务，按照记录的更新时间定时清除或者增加超时时间字段，sql 中进行优化</p></li><li><p>可重入性：通过增加字段，记录占有锁的应用节点信息和线程信息，再次获取锁时判断是否是当前线程获取的锁达到可重入的特性。</p></li><li><p>非阻塞特性：具备，在获取锁失败时，会直接返回失败。但是无法满足超时获取的场景，比如5秒内获取不到锁再失败等。</p></li></ol><h2 id="基于zookeeper" tabindex="-1"><a class="header-anchor" href="#基于zookeeper"><span>基于ZooKeeper</span></a></h2><h3 id="临时-znode" tabindex="-1"><a class="header-anchor" href="#临时-znode"><span>临时 znode</span></a></h3><ol><li>节点尝试创建临时 znode，此时创建成功了就获取了这个锁</li><li>其他客户端来创建锁会失败，只能<strong>注册个监听器</strong>监听这个锁</li><li>释放锁就是删除这个 znode，一旦释放掉就会通知客户端</li><li>等待着的客户端就可以再次重新加锁。</li></ol><p><strong>羊群效应:如果有1000个客户端发起请求并创建临时节点，都会去监听A结点的变化，然后A删除节点的时候会通知其他节点，耗费资源了</strong></p><h3 id="临时顺序节点" tabindex="-1"><a class="header-anchor" href="#临时顺序节点"><span>临时顺序节点</span></a></h3><p>临时节点和顺序节点的结合体，每个节点创建时会指定顺序编号，并且在客户端与ZK服务端断开时，节点会被删除。</p><ol><li>创建一个持久节点表示一个分布式锁节点</li><li>所有客户端都尝试去创建临时有序节点以获取锁</li><li>序号最小的临时有序节点获得锁</li><li>未获取到锁的客户端给自己的上一个临时有序节点添加监听</li><li>获得锁的客户端进行自己的操作，操作完成之后删除自己的临时有序节点</li><li>当监听到自己的上一个临时有序节点释放了锁，尝试自己去加锁</li><li>操作完成之后释放锁</li><li>之后剩下的客户端重复加锁和解锁的操作</li></ol><p>JVM 调优，尽量避免长时间 GC 的情况发生：</p><p><strong>由于ZK依靠session定期的心跳来维持客户端，如果客户端进入长时间的GC，可能会导致ZK认为客户端宕机而释放锁，让其他的客户端获取锁，但是客户端在GC回复后，会认为自己还持有锁。</strong></p><h2 id="基于redis" tabindex="-1"><a class="header-anchor" href="#基于redis"><span>基于Redis</span></a></h2><h3 id="基于-lua-脚本" tabindex="-1"><a class="header-anchor" href="#基于-lua-脚本"><span>基于 lua 脚本</span></a></h3><p>采用Lua脚本，来保证SETNX+EXPIRE+随机value操作的原子性。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">getLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">String</span> uniId<span class="token punctuation">,</span><span class="token class-name">Long</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//加锁</span>
    <span class="token keyword">return</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> uniId<span class="token punctuation">,</span> <span class="token string">&quot;NX&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;EX&quot;</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 解锁</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">releaseLock</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span><span class="token class-name">String</span> uniId<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 因为get和del操作并不是原子的，所以使用lua脚本</span>
    <span class="token class-name">String</span> lua_script <span class="token operator">=</span> &quot;<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token char">&#39;get&#39;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">ARGV</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then  <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token char">&#39;del&#39;</span><span class="token punctuation">,</span><span class="token constant">KEYS</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token operator">+</span><span class="token string">&quot;else return 0  end;&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>lua_scripts<span class="token punctuation">,</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>uniId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>随机值防止锁误删，一些情况下，执行时间超过了锁过期时间，此时其他线程也获取到了锁，如果直接删除，导致更多的客户端能够获取到锁。</p><h2 id="redlock-算法" tabindex="-1"><a class="header-anchor" href="#redlock-算法"><span>RedLock 算法</span></a></h2><p>RedLock的核心原理：</p><ul><li>在Redis集群中选出多个Master节点，保证这些Master节点不会同时宕机；</li><li>并且各个Master节点之间相互独立，数据不同步；</li><li>使用与Redis单实例相同的方法来加锁和解锁。</li></ul><p>那么RedLock到底是如何来保证在有节点宕机的情况下，还能安全的呢？</p><ol><li>假设集群中有N台Master节点，首先，获取当前时间戳；</li><li>客户端按照顺序使用相同的key,value依次获取锁，并且获取时间要比锁超时时间足够小；比如超时时间5s,那么获取锁时间最多1s，超过1s则放弃，继续获取下一个；</li><li>客户端通过获取所有能获取的锁之后减去第一步的时间戳，这个时间差要小于锁超时时间，并且要至少有N/2 + 1台节点获取成功，才表示锁获取成功，否则算获取失败；</li><li>如果成功获取锁，则锁的有效时间是原本超时时间减去第三不得时间差；</li><li>如果获取锁失败，则要解锁所有的节点，不管该节点加锁时是否成功，防止有漏网之鱼。</li></ol><h2 id="方案总结" tabindex="-1"><a class="header-anchor" href="#方案总结"><span>方案总结</span></a></h2><ul><li>分布式锁，数据库本身就不适合分布式锁，并发不高的情况下可以尝试</li><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。</li><li>Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。</li></ul>`,30),p=[t];function i(o,c){return s(),a("div",null,p)}const r=n(l,[["render",i],["__file","分布式锁.html.vue"]]),d=JSON.parse('{"path":"/design/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"分布式锁","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"分布式锁特性","slug":"分布式锁特性","link":"#分布式锁特性","children":[]},{"level":2,"title":"基于数据库","slug":"基于数据库","link":"#基于数据库","children":[]},{"level":2,"title":"基于ZooKeeper","slug":"基于zookeeper","link":"#基于zookeeper","children":[{"level":3,"title":"临时 znode","slug":"临时-znode","link":"#临时-znode","children":[]},{"level":3,"title":"临时顺序节点","slug":"临时顺序节点","link":"#临时顺序节点","children":[]}]},{"level":2,"title":"基于Redis","slug":"基于redis","link":"#基于redis","children":[{"level":3,"title":"基于 lua 脚本","slug":"基于-lua-脚本","link":"#基于-lua-脚本","children":[]}]},{"level":2,"title":"RedLock 算法","slug":"redlock-算法","link":"#redlock-算法","children":[]},{"level":2,"title":"方案总结","slug":"方案总结","link":"#方案总结","children":[]}],"git":{"updatedTime":1694156727000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"design/distributed/分布式锁.md"}');export{r as comp,d as data};
