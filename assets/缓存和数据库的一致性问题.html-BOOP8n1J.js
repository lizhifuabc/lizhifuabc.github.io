import{_ as l,o as i,c as e,a}from"./app-oJgUVX7T.js";const s="/assets/image-20230910171044918-_2y4XVO5.png",t="/assets/image-20230910171110623-4p7ezh1W.png",p="/assets/image-20230910171155451-Cs6Tcl-9.png",n="/assets/image-20230910171212873-CiaKrhws.png",r="/assets/image-20230910171227401-DLGKeB7Z.png",c="/assets/image-20230910171317000-DcZOOzWe.png",o="/assets/image-20230910171256573-Du1gTmES.png",h="/assets/image-20230910171339495-DrI_fbCq.png",d={},g=a('<h1 id="缓存和数据库的一致性问题" tabindex="-1"><a class="header-anchor" href="#缓存和数据库的一致性问题"><span>缓存和数据库的一致性问题</span></a></h1><p>从本质上讲，无论是先写数据库还是先写缓存，都是为了保证数据库和缓存的数据一致。数据库和缓存（redis）双写数据一致性问题，在高并发的场景下，这个问题尤为严重。</p><p>首先：只要是双写，总会有数据一致性的问题，大多数情况下我们并不是严格要求<strong>缓存+数据库</strong> 必须保持一致性。</p><p>简单数据获取流程：</p><p><img src="'+s+'" alt="image-20230910171044918"></p><h2 id="缓存删除而不是更新" tabindex="-1"><a class="header-anchor" href="#缓存删除而不是更新"><span>缓存删除而不是更新</span></a></h2><p>其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。</p><p><img src="'+t+'" alt="image-20230910171110623"></p><h2 id="常见的四种方案" tabindex="-1"><a class="header-anchor" href="#常见的四种方案"><span>常见的四种方案</span></a></h2><ol><li>先更新缓存，再更新数据库</li><li>先更新数据库，再更新缓存</li><li>先删缓存，再更新数据库</li><li>先更新数据库，再删缓存</li></ol><h3 id="先更新缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#先更新缓存-再更新数据库"><span>先更新缓存，再更新数据库</span></a></h3><p><img src="'+p+'" alt="image-20230910171155451"></p><p>此时缓存和数据库中的数据出现不一致，缓存中的数据也就没有了意义。</p><h3 id="先更新数据库-再更新缓存" tabindex="-1"><a class="header-anchor" href="#先更新数据库-再更新缓存"><span>先更新数据库，再更新缓存</span></a></h3><p><img src="'+n+'" alt="image-20230910171212873"></p><p>数据库是新数据，而缓存是旧数据或者没有数据，出现数据不一致的情况。</p><p><img src="'+r+'" alt="image-20230910171227401"></p><p>步骤说明（图中顺序为请求顺序）：</p><ol><li>请求1：进行到步骤2时出现问题，此时发生了延迟</li><li>请求2：步骤3、4，顺利执行</li><li>请求1：步骤2此时才开始执行。</li><li>请求3：获取缓存内的数据，此时获取到的是请求1写入缓存的数据，此时读取的是旧数据。</li></ol><h3 id="先删除缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#先删除缓存-再更新数据库"><span>先删除缓存，再更新数据库</span></a></h3><ul><li>数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致</li><li>读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。</li></ul><p><img src="'+c+'" alt="image-20230910171317000"></p><h3 id="推荐-先更新数据库-再删除缓存-删除重试" tabindex="-1"><a class="header-anchor" href="#推荐-先更新数据库-再删除缓存-删除重试"><span>推荐：先更新数据库，再删除缓存（删除重试）</span></a></h3><p>先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。</p><p><img src="'+o+'" alt="image-20230910171256573"></p><blockquote><p>此时可以添加重试删除操作，直到成功（对业务线代码造成大量的侵入）。</p></blockquote><h3 id="推荐-先更新数据库-再删除缓存-延时双删" tabindex="-1"><a class="header-anchor" href="#推荐-先更新数据库-再删除缓存-延时双删"><span>推荐：先更新数据库，再删除缓存（延时双删）</span></a></h3><p>依旧是<strong>先更新数据库，再删除缓存</strong>，一段时间间隔后再一次删除缓存。</p><p><img src="'+h+'" alt="image-20230910171339495"></p><p>方案一：</p><ol><li><p>更新数据库数据</p></li><li><p>数据库将数据表数据的变更信息写入binlog日志当中</p></li><li><p>订阅程序获取所需要的数据以及key</p></li><li><p>程序逻辑中处理具体的业务逻辑，接收订阅binlog、发起删除缓存的请求。</p></li><li><p>尝试删除缓存操作，发现删除失败</p></li><li><p>将这些信息发送至消息队列</p></li><li><p>重新从消息队列中获得该数据，重试操作。</p></li></ol><p>其他：</p><ul><li>使用 <code>DelayQueue</code>，会随着 JVM 进程的死亡，丢失更新的风险</li><li>使用 <code>MQ</code></li><li>缓存设置有效期</li><li>订阅 Mysql 数据库的 binlog 日志对缓存进行操作</li></ul>',33),m=[g];function _(u,b){return i(),e("div",null,m)}const E=l(d,[["render",_],["__file","缓存和数据库的一致性问题.html.vue"]]),k=JSON.parse('{"path":"/database/nosql/%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98.html","title":"缓存和数据库的一致性问题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"缓存删除而不是更新","slug":"缓存删除而不是更新","link":"#缓存删除而不是更新","children":[]},{"level":2,"title":"常见的四种方案","slug":"常见的四种方案","link":"#常见的四种方案","children":[{"level":3,"title":"先更新缓存，再更新数据库","slug":"先更新缓存-再更新数据库","link":"#先更新缓存-再更新数据库","children":[]},{"level":3,"title":"先更新数据库，再更新缓存","slug":"先更新数据库-再更新缓存","link":"#先更新数据库-再更新缓存","children":[]},{"level":3,"title":"先删除缓存，再更新数据库","slug":"先删除缓存-再更新数据库","link":"#先删除缓存-再更新数据库","children":[]},{"level":3,"title":"推荐：先更新数据库，再删除缓存（删除重试）","slug":"推荐-先更新数据库-再删除缓存-删除重试","link":"#推荐-先更新数据库-再删除缓存-删除重试","children":[]},{"level":3,"title":"推荐：先更新数据库，再删除缓存（延时双删）","slug":"推荐-先更新数据库-再删除缓存-延时双删","link":"#推荐-先更新数据库-再删除缓存-延时双删","children":[]}]}],"git":{"updatedTime":1715597425000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":2}]},"filePathRelative":"database/nosql/缓存和数据库的一致性问题.md"}');export{E as comp,k as data};
