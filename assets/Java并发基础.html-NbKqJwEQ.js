import{_ as a,o as n,c as e,a as s}from"./app-oJgUVX7T.js";const p="/assets/java-bingfa-2-DvPj1-wq.jpeg",l="/assets/java-bingfa-1-LzDQ5xsp.jpeg",t={},i=s(`<h1 id="java并发基础" tabindex="-1"><a class="header-anchor" href="#java并发基础"><span>Java并发基础</span></a></h1><ul><li>可见性：CPU 增加了缓存，以均衡与内存的速度差异，导致可见性问题</li><li>有序性：操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，导致原子性问题</li><li>原子性：编译程序优化指令执行次序，使得缓存能够得到更加合理地利用， 导致有序性问题</li></ul><p>JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><h2 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性"><span>原子性</span></a></h2><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment">//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment">//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span>
x<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token comment">//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span>
x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">//语句4： 同语句3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面4个语句只有语句1的操作具备原子性。</p><p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h2 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性"><span>可见性</span></a></h2><p>Java提供了volatile关键字来保证可见性。</p><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><h2 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性"><span>有序性</span></a></h2><p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。</p><h2 id="线程安全" tabindex="-1"><a class="header-anchor" href="#线程安全"><span>线程安全</span></a></h2><ol><li><p><strong>互斥同步(阻塞同步)</strong></p><p>synchronized 和 ReentrantLock。</p></li><li><p><strong>非阻塞同步</strong></p><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p></li><li><p>CAS</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p></li><li><p>AtomicInteger</p><p>J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p></li><li><p><strong>无同步方案</strong></p><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p></li><li><p>栈封闭</p><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p></li><li><p>线程本地存储(Thread Local Storage)</p><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p></li></ol><h2 id="并发和并行" tabindex="-1"><a class="header-anchor" href="#并发和并行"><span>并发和并行</span></a></h2><p>并发是指一个处理器同时处理多个任务。</p><p><img src="`+p+'" alt="img"></p><p>并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</p><p><img src="'+l+'" alt="img"></p><blockquote><p>https://pdai.tech/md/interview/x-interview.html#_3-1-%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80</p></blockquote>',25),o=[i];function c(r,d){return n(),e("div",null,o)}const v=a(t,[["render",c],["__file","Java并发基础.html.vue"]]),m=JSON.parse('{"path":"/java/concurrent/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80.html","title":"Java并发基础","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"原子性","slug":"原子性","link":"#原子性","children":[]},{"level":2,"title":"可见性","slug":"可见性","link":"#可见性","children":[]},{"level":2,"title":"有序性","slug":"有序性","link":"#有序性","children":[]},{"level":2,"title":"线程安全","slug":"线程安全","link":"#线程安全","children":[]},{"level":2,"title":"并发和并行","slug":"并发和并行","link":"#并发和并行","children":[]}],"git":{"updatedTime":1694847225000,"contributors":[{"name":"拔土豆的程序员","email":"lizhifuabc@163.com","commits":1}]},"filePathRelative":"java/concurrent/Java并发基础.md"}');export{v as comp,m as data};
