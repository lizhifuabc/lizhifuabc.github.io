# Spring中事务以及事务的传播机制

事务是一种用于管理数据库操作的机制。它将一组操作封装成一个单元，确保数据库操作要么全部成功提交，要么全部回滚，以保持数据的一致性和完整性。

## 基础概念

## 事务特性

事务具有四个重要的特性，通常被称为 ACID 特性：

1. 原子性（Atomicity）：原子性要求事务被视为不可分割的最小工作单元，要么全部执行成功，要么全部失败回滚。事务在执行过程中发生错误或中断，系统必须能够将其恢复到事务开始前的状态，保证数据的一致性。
2. 一致性（Consistency）：一致性确保事务在执行前后数据库的状态是一致的。事务在执行过程中对数据库进行的修改必须满足预定义的规则和约束，以保证数据的完整性。
3. 隔离性（Isolation）：隔离性指多个事务并发执行时，每个事务的操作都应当与其他事务相互隔离，使它们感觉不到其他事务的存在。隔离性可以防止并发执行的事务之间发生干扰和数据冲突，确保数据的正确性。
4. 持久性（Durability）：持久性要求事务一旦提交，其对数据库的修改就是永久性的，即使在系统发生故障或重启的情况下，修改的数据也能够被恢复。持久性通过将事务的结果写入非易失性存储介质（如磁盘）来实现。

## 事务的隔离级别

四个隔离级别：

1. `Read Uncommitted（读取未提交数据）`：最低的隔离级别。在该级别下，一个事务可以读取到另一个事务未提交的数据，可能导致**脏读**，即读取到了未经验证的数据。这个级别会导致数据的不一致性，并且不提供任何并发控制。
2. `Read Committed（读取已提交数据）`：在该级别下，一个事务只能读取到已经提交的数据。它避免了脏读，但可能出现不可重复读（Non-repeatable Read）的问题。**不可重复读**是指同一个事务中多次读取同一数据，在事务执行过程中，该数据被其他事务修改，导致每次读取到的值不一致。
3. `Repeatable Read（可重复读）`：在该级别下，一个事务在执行期间多次读取同一数据时，保证能够读取到一致的结果。即使其他事务对该数据进行修改，也不会影响当前事务的读取操作。这个级别通过锁定读取的数据，避免了不可重复读，但可能出现幻读（Phantom Read）的问题。**幻读**是指同一个事务中多次查询同一个范围的数据时，由于其他事务插入了新的数据，导致每次查询结果集不一致。
4. `Serializable（可串行化）`：最高的隔离级别，它要求事务串行执行，完全避免了并发问题。在该级别下，事务之间互相看不到对方的操作，可以避免脏读、不可重复读和幻读等问题。然而，由于串行化执行，会牺牲一定的并发性能。

## 事务传播机制

事务传播机制是指定事务在方法调用之间如何传播和影响的机制，通过定义事务的传播行为，**控制事务在不同方法之间的创建、挂起、恢复和回滚操作。**

常见事务传播行为：

1. REQUIRED（默认）：如果当前存在事务，则加入到当前事务中，如果没有事务，则创建一个新的事务。
2. SUPPORTS：如果当前存在事务，则加入到当前事务中，如果没有事务，则以非事务的方式执行。
3. MANDATORY：必须在一个已存在的事务中执行，否则抛出异常。
4. REQUIRES_NEW：每次都会创建一个新的事务，如果当前存在事务，则将当前事务挂起。
5. NOT_SUPPORTED：以非事务的方式执行操作，如果当前存在事务，则将当前事务挂起。
6. NEVER：必须以非事务方式执行，如果当前存在事务，则抛出异常。
7. NESTED：如果当前存在事务，则在嵌套事务内执行，如果没有事务，则创建一个新的事务。子事务可以独立提交或回滚，而不会影响父事务的其他步骤。当外部事务回滚时，会导致内部事务也被回滚，即使内部事务已经执行了一些提交操作。

## Spring 中事务的实现

Spring中，事务是基于线程的，每个线程都有一个事务上下文。如果在方法调用期间已经存在一个事务上下文（即已经开启了一个事务），则可以说"当前存在事务"。

当一个方法被调用时，Spring会检查当前线程是否已经有一个事务上下文存在。如果有，那么这个方法就可以在这个已存在的事务上下文中执行，即在当前事务中执行。方法可以访问和操作当前事务中的数据，并共享该事务的一致性和隔离级别（取决于方法的事务传播行为设置）。

如果当前线程没有事务上下文存在，那么方法可以选择创建一个新的事务，或者以非事务方式执行。这取决于方法的事务传播行为设置。新的事务上下文会在方法开始时创建，并在方法执行完毕后进行提交或回滚。

例如，一个方法A内部调用了另一个方法B，如果方法B具有REQUIRED（默认）的事务传播行为，而方法A已经在一个事务中执行，那么方法B将加入到方法A的事务中，共同参与事务的操作。

1. 编程式事务

   ```java
   public static <R,P> R runWithTransactional(int propagationBehavior,
                                     P parameter,
                                     Function<P,R> processFun,
                                     R defaultResult){
       // 开启事务
       DefaultTransactionDefinition def = new DefaultTransactionDefinition();
       def.setPropagationBehavior(propagationBehavior);
       // 获取事务管理器，DataSourceTransactionManager
       PlatformTransactionManager transactionManager = SpringContextUtil.getBean(PlatformTransactionManager.class);
       TransactionStatus transactionStatus = transactionManager.getTransaction(def);
       try {
          R result = processFun.apply(parameter);
          transactionManager.commit(transactionStatus);
          return result;
       }catch (Exception e){
          log.warn("事务执行异常:",e);
          // 回滚事务
          transactionManager.rollback(transactionStatus);
          return defaultResult;
       }
   }
   ```

2. 声明式事务（注解） **@Transactional**

## 声明式事务（注解） **@Transactional**

无需手动开启事务和提交事务，进入方法时自动开启事务，方法执行完会自动提交事务，如果中途发生了没有处理的异常会自动回滚事务。

> 如果手动处理了异常，事务将不会回滚

### **作用范围**

- 修饰方法时，只对`public`的方法生效。
- 修饰类时，对该类中所有的`public`方法生效。

> 事务管理机制是通过代理的方式在运行时创建代理对象，并且代理对象只能访问`public`方法。所以当`@Transactional`注解应用于非`public`方法（如`protected`、`private`或默认包可见性的方法）时，此时代理对象无法访问这些方法，导致事务管理无法生效。

### **参数说明**

1. propagation：事务的传播行为

2. isolation：事务的隔离级别

3. readOnly：事务是否为只读，如果设置为 true，则表示该事务只读取数据，不修改数据。

4. timeout：事务超时时间，单位为秒。如果事务执行时间超过指定的超时时间，则事务会被强制回滚。

5. rollbackFor：指定哪些异常触发事务回滚。可以指定一个或多个异常类型的数组。

6. rollbackForClassName：指定哪些异常类名触发事务回滚。可以指定一个或多个异常类名的字符串数组。

7. noRollbackFor：指定哪些异常不触发事务回滚。可以指定一个或多个异常类型的数组。

8. noRollbackForClassName：指定哪些异常类名不触发事务回滚。可以指定一个或多个异常类名的字符串数组。

## **工作原理**

1. 通过代理对象调用被代理的方法。
2. 代理对象在方法调用前执行事务管理。
3. 代理对象将实际的方法调用委托给原对象。使原对象执行实际的业务逻辑。
4. 原对象返回方法的结果给代理对象。
5. 代理对象在方法调用后执行事务管理的提交或回滚。
6. 代理对象将方法的结果返回给调用者。