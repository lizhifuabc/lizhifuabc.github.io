# 基本数据类型和引用数据类型

Java 是一种静态类型的编程语言，这意味着所有变量必须在使用之前声明好，也就是必须得先指定变量的类型和名称。

## 基本数据类型

基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。

整数类型：

- `byte`: 8位有符号整数，取值范围为-128到127。
- `short`: 16位有符号整数。
- `int`: 32位有符号整数，通常是最常用的整数类型。
- `long`: 64位有符号整数

- 浮点数类型：
  - `float`: 32位单精度浮点数。
  - `double`: 64位双精度浮点数，通常是最常用的浮点数类型。

- 字符类型：
  - `char`: 16位Unicode字符。
- 布尔类型：
  - `boolean`: 表示真或假的值。

## 引用数据类型

1. 引用数据类型用于引用对象，而不是直接存储值。它们包括类（Class）、接口（Interface）、枚举（Enum）和数组（Array）等类型。
2. 引用数据类型的变量存储的是对象的引用，而不是对象本身。当你创建一个对象时，实际上是在**堆内存**中分配了一块内存，并将其地址（引用）存储在引用变量中。

```java
String myString = "Hello, World!";
```

在这个示例中，`myString`是一个引用类型的变量，它引用了一个`String`对象。

## 区别

**1. 内存管理：**

- **基本数据类型**：
  - 基本数据类型的值直接存储在栈（stack）内存中，这是一块较小但快速分配和释放的内存区域。
  - 基本数据类型的变量的生命周期与其所在方法的生命周期相匹配，当方法执行完毕时，它们就会被销毁。
  - 这种方式使得基本数据类型的内存管理非常高效。
- **引用数据类型**：
  - 引用数据类型的对象通常存储在堆内存中。
  - 堆内存的分配和释放比栈内存复杂，需要进行垃圾回收来管理不再被引用的对象，以释放内存。
  - 因为对象的生命周期可以跨越多个方法调用，所以它们的内存管理相对较复杂。这也可能导致内存泄漏的问题，如果不谨慎管理引用数据类型的对象。

**2. 数据处理：**

- **基本数据类型**：基本数据类型通常比引用数据类型更快速，因为它们存储的是简单的数值，不涉及对象的方法调用或额外的内存访问。对于数值计算和基本操作，基本数据类型通常更有效率。
- **引用数据类型**：
  - 引用数据类型的对象通常包含多个字段和方法，访问这些字段和调用方法需要额外的时间。
  - 对象的引用被存储在栈（stack）中，而对象本身存储在堆（heap）中，所以访问对象的字段和方法需要通过引用来间接访问。这种间接性可能会导致引用数据类型的操作相对较慢。

**3. 复杂性：**

- **基本数据类型**：基本数据类型是简单的值类型，没有方法或属性。它们在处理和操作时通常不会引入复杂性。
- **引用数据类型**：引用数据类型通常包含复杂的结构和方法，可能需要更多的代码和逻辑来处理。这可以增加代码的复杂性和维护成本。

## String 的特殊性

1. 不可变性（Immutability）：String对象是不可变的，一旦创建，其值就不能被修改。这意味着每次对String对象进行修改时，实际上是创建了一个新的String对象，而原来的String对象保持不变。这种设计保证了String对象在多线程环境下的安全性，并且可以进行字符串常量池的优化。   
2. 字符串常量池（String Pool）：Java中的字符串常量池是一种特殊的内存区域，用于存储字符串常量。当创建一个字符串常量时，JVM会首先检查常量池中是否已经存在该字符串，如果存在，则直接返回常量池中的引用，避免了重复创建相同内容的字符串对象。这样可以节省内存空间，并提高字符串的比较效率。   
3. 字符串连接优化：在Java中，使用"+"操作符连接字符串时，编译器会对其进行优化，将多个字符串连接操作转换为使用StringBuilder或StringBuffer进行拼接。这样可以避免频繁创建新的字符串对象，提高字符串连接的效率。   
4. 字符串操作方法：String类提供了丰富的方法用于操作字符串，例如截取子串、查找字符、替换字符等。这些方法使得字符串的处理更加方便和灵活。 

## 堆（heap）和栈（stack）

堆（heap）:

程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里。

1. new 一个对象
2. 内存的“堆”区分配空间



栈（stack）：

Java 对象的引用放在栈里， Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用

